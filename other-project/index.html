<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar â€“ AI Assistant</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Vercel Geist UI Inspired Styles --- */
        :root {
            --bg-light: #ffffff;
            --bg-dark: #000000;
            --text-light: #000000;
            --text-dark: #ffffff;
            --panel-dark: #111111;
            --border-light: #eaeaea;
            --border-dark: #333333;
            --accent: #0070f3;
            --geist-gray: #666666;
        }

        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            transition: background-color 0.2s, color 0.2s;
            display: flex;
            flex-direction: column;
        }

        .light-theme { background-color: var(--bg-light); color: var(--text-light); }
        .dark-theme { background-color: var(--bg-dark); color: var(--text-dark); }

        .panel {
            transition: background-color 0.2s;
            border-color: var(--border-light);
        }
        .dark-theme .panel { border-color: var(--border-dark); }
        .light-theme .panel { background-color: var(--bg-light); }
        .dark-theme .panel { background-color: var(--panel-dark); }

        .chat-bubble { max-width: 90%; padding: 10px 16px; border-radius: 12px; word-wrap: break-word; line-height: 1.6; }
        .user-bubble { background-color: var(--accent); color: white; }
        .stellar-bubble { background-color: transparent; padding: 0; }
        .stellar-bubble a { color: var(--accent); text-decoration: none; border-bottom: 1px solid var(--accent); }
        .stellar-bubble a:hover { background-color: var(--accent); color: white; }
        .stellar-bubble ul { list-style-position: inside; padding-left: 8px; }
        .stellar-bubble h3 { font-size: 1.1rem; font-weight: 600; margin-bottom: 8px; }

        .toolbar-icon { cursor: pointer; transition: color 0.2s ease; color: var(--geist-gray); }
        .toolbar-icon:hover { color: var(--accent); }

        .input-container {
            position: relative;
            display: flex;
            align-items: center;
            padding: 8px;
            border: 1px solid var(--border-light);
            border-radius: 12px;
            background-color: var(--bg-light);
        }
        .dark-theme .input-container {
            border-color: var(--border-dark);
            background-color: var(--bg-dark);
        }
        .input-container:focus-within {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(0, 112, 243, 0.2);
        }

        .input-field {
            flex-grow: 1;
            background: transparent;
            border: none;
            outline: none;
            padding: 8px 48px 8px 40px; /* Padding for icons */
            font-size: 1rem;
            line-height: 1.5;
            resize: none;
            overflow-y: hidden; /* Hide scrollbar, handled by JS */
        }

        .input-icon {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--geist-gray);
        }
        .input-icon.mic { left: 16px; }
        .input-icon.send { right: 16px; background-color: var(--accent); color: white; border-radius: 8px; padding: 6px; cursor: pointer; }
        .input-icon.send:hover { background-color: #0056b3; }


        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        .dark-theme ::-webkit-scrollbar-thumb { background: #444; }

        .fade-in { animation: fadeIn 0.3s ease-out forwards; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .switch { position: relative; display: inline-block; width: 46px; height: 26px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .3s; border-radius: 26px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; }
        input:checked+.slider { background-color: var(--accent); }
        input:checked+.slider:before { transform: translateX(20px); }

        .data-card { margin-top: 12px; padding: 16px; border: 1px solid var(--border-light); border-radius: 8px; }
        .dark-theme .data-card { border-color: var(--border-dark); }
        .news-article { margin-top: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border-light); }
        .dark-theme .news-article { border-color: var(--border-dark); }
        .news-article:last-child { border-bottom: none; }
    </style>
</head>

<body class="light-theme">

    <div id="app-container" class="w-full h-full flex flex-col opacity-0">
        <header class="flex justify-between items-center text-center p-4 border-b panel">
            <div class="w-10"></div> <!-- Spacer -->
            <h1 class="text-xl font-semibold tracking-tight">Stellar</h1>
            <div id="settings-btn" class="toolbar-icon w-10" title="Settings"><i class="material-icons">settings</i></div>
        </header>
        <main class="flex-grow flex flex-col overflow-hidden">
            <div id="chat-messages" class="flex-grow overflow-y-auto p-4 space-y-4"></div>
        </main>
        <footer class="p-2 sm:p-4 border-t panel">
            <div class="input-container">
                <div class="input-icon mic"><i class="material-icons">mic</i></div>
                <textarea id="chat-input" class="input-field" placeholder="Ask Stellar anything..." rows="1"></textarea>
                <div id="send-button" class="input-icon send"><i class="material-icons">arrow_upward</i></div>
            </div>
        </footer>
    </div>

    <div id="settings-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
        <div class="bg-white dark:bg-black border border-gray-200 dark:border-gray-800 p-6 rounded-2xl w-full max-w-md">
            <div class="flex justify-between items-center">
                <h2 class="text-xl font-bold">Settings</h2>
                <button id="close-settings" class="toolbar-icon"><i class="material-icons">close</i></button>
            </div>
            <div class="mt-6 space-y-6">
                <div class="flex justify-between items-center">
                    <span>Dark Mode</span>
                    <label class="switch"><input type="checkbox" id="dark-mode-toggle"><span class="slider"></span></label>
                </div>
                <div class="flex justify-between items-center">
                    <span>Clear Chat History</span>
                    <button id="clear-history-btn" class="px-3 py-1 bg-red-500 text-white rounded-lg text-sm">Clear</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION ---
            const CONFIG = {
                API_KEY: "AIzaSyCgX5yszHAZyBe9_S9GLw-JKXWSaUBqFsY",
                PROXY_URL: 'https://blkproxy.vercel.app/api/proxy?url=',
                API_BASE_URL: 'https://swipeapis.vercel.app',
                MODEL_NAME: 'gemini-1.5-pro-latest'
            };

            // --- GET ALL HTML ELEMENTS ---
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-button');
            const micButton = document.querySelector('.input-icon.mic');
            const settingsBtn = document.getElementById('settings-btn');
            const settingsModal = document.getElementById('settings-modal');
            const closeSettingsBtn = document.getElementById('close-settings');
            const darkModeToggle = document.getElementById('dark-mode-toggle');
            const clearHistoryBtn = document.getElementById('clear-history-btn');
            const appContainer = document.getElementById('app-container');

            let chatHistory = [];
            let lastNewsQuery = null;

            // --- AUTO-RESIZING TEXTAREA ---
            const adjustTextareaHeight = () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = (chatInput.scrollHeight) + 'px';
            };
            chatInput.addEventListener('input', adjustTextareaHeight);

            // --- Message Handling ---
            const addMessage = (sender, message, isRawHtml = false) => {
                const messageId = `msg-${Date.now()}`;
                const messageElement = document.createElement('div');
                messageElement.className = 'w-full flex fade-in';
                messageElement.id = messageId;
                const bubble = document.createElement('div');
                bubble.className = 'chat-bubble';
                if (sender === 'user') {
                    messageElement.classList.add('justify-end');
                    bubble.classList.add('user-bubble');
                    bubble.textContent = message;
                } else {
                    messageElement.classList.add('justify-start');
                    bubble.classList.add('stellar-bubble');
                    bubble[isRawHtml ? 'innerHTML' : 'textContent'] = message;
                }
                messageElement.appendChild(bubble);
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                if (sender !== 'system') {
                    // Save the raw message and the flag to render it as HTML correctly
                    chatHistory.push({ sender, message, isRawHtml, id: messageId });

                    // Enforce the 20-message limit
                    if (chatHistory.length > 20) {
                        chatHistory.shift(); // Remove the oldest message
                    }

                    saveChatHistory();
                }
                return messageId;
            };

            const updateMessage = (messageId, newMessage, isRawHtml = false) => {
                const bubble = document.getElementById(messageId)?.querySelector('.chat-bubble');
                if (bubble) {
                    bubble[isRawHtml ? 'innerHTML' : 'textContent'] = newMessage;
                }
                const historyItem = chatHistory.find(item => item.id === messageId);
                if (historyItem) {
                    historyItem.message = isRawHtml ? `[Stellar displayed a visual element]` : newMessage;
                    saveChatHistory();
                }
            };

            const showTypingIndicator = (message = null) => {
                hideTypingIndicator();
                const typingElement = document.createElement('div');
                typingElement.id = 'typing-indicator';
                typingElement.className = 'w-full flex justify-start fade-in pl-4';
                const content = message
                    ? `<p class="text-sm text-gray-500 dark:text-gray-400">${message}</p>`
                    : `<div class="chat-bubble stellar-bubble flex items-center space-x-1"><span class="w-2 h-2 bg-gray-400 rounded-full animate-pulse"></span><span class="w-2 h-2 bg-gray-400 rounded-full animate-pulse" style="animation-delay: 0.2s;"></span><span class="w-2 h-2 bg-gray-400 rounded-full animate-pulse" style="animation-delay: 0.4s;"></span></div>`;
                typingElement.innerHTML = content;
                chatMessages.appendChild(typingElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            };
            const hideTypingIndicator = () => document.getElementById('typing-indicator')?.remove();

            const simpleMarkdownToHtml = (text) => {
                let html = text
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>');
                html = html.replace(/^\s*\*\s+(.*)/gm, '<li>$1</li>');
                html = html.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
                html = html.replace(/<\/ul>\s*<ul>/g, '');
                return html.replace(/\n/g, '<br>');
            };

            // --- Main Logic ---
            const handleSendMessage = async () => {
                const userInput = chatInput.value.trim();
                if (userInput === '') return;
                addMessage('user', userInput);
                chatInput.value = '';
                adjustTextareaHeight();
                showTypingIndicator();
                try {
                    const stellarResponse = await getStellarResponse(userInput);
                    hideTypingIndicator();
                    processStellarResponse(stellarResponse, userInput);
                } catch (error) {
                    hideTypingIndicator();
                    console.error("Error from Stellar:", error);
                    addMessage('stellar', 'I seem to be having trouble connecting. Please check your API key and try again.');
                }
            };

            const processStellarResponse = (response, originalUserInput) => {
                if (!response?.parts?.[0]?.text) {
                    addMessage('stellar', "I'm sorry, I couldn't process that request. The API might have returned an empty response.");
                    return;
                }
                let cleanText = response.parts[0].text.trim();
                if (cleanText.startsWith('```json')) {
                    cleanText = cleanText.replace(/^```json\s*|```$/g, '');
                }
                try {
                    const parsedJson = JSON.parse(cleanText);
                    switch (parsedJson.type) {
                        case 'text':
                            addMessage('stellar', parsedJson.content, true);
                            break;
                        case 'search':
                            handleSearchAndRespond(parsedJson.content, originalUserInput);
                            break;
                        case 'fetch_stock':
                            fetchAndDisplayStock(parsedJson.content);
                            break;
                        case 'fetch_comparison':
                            fetchAndCompareStocks(parsedJson.content);
                            break;
                        case 'fetch_news':
                            fetchAndDisplayNews(parsedJson.content);
                            break;
                        case 'fetch_more_news':
                            if (lastNewsQuery) {
                                const newParams = { ...lastNewsQuery, start: (lastNewsQuery.start || 0) + 10 };
                                fetchAndDisplayNews({ params: newParams, commentary: "Of course, here are the next 10 articles:" });
                            } else {
                                addMessage('stellar', "I don't have a previous news search to show you more of. Please start a new search first!");
                            }
                            break;
                        default:
                            addMessage('stellar', parsedJson.content || "Received an unknown response type.");
                    }
                } catch (e) {
                    console.warn("Failed to parse JSON, treating as markdown.", e);
                    const formattedHtml = simpleMarkdownToHtml(cleanText);
                    addMessage('stellar', formattedHtml, true);
                }
            };

            const handleSearchAndRespond = async (content, originalUserInput) => {
                const { query } = content;
                const messageId = addMessage('stellar', `Searching for "${query}"...`);
                try {
                    const searchResults = await googleSearchAPI(query);
                    if (!searchResults.results || searchResults.results.length === 0) {
                        updateMessage(messageId, `I couldn't find any results for "${query}".`);
                        return;
                    }

                    updateMessage(messageId, 'Analyzing search results...');
                    let searchDataForAI = "Here are the top Google search results. Please synthesize this information to provide a comprehensive answer to the user's original query. Respond in clear, well-formatted HTML if necessary.\n\n";
                    searchResults.results.forEach(res => {
                        searchDataForAI += `Title: ${res.title}\nURL: ${res.url}\nDescription: ${res.description}\n\n`;
                    });

                    const finalResponse = await getStellarResponse(originalUserInput, searchDataForAI);

                    if (finalResponse?.parts?.[0]?.text) {
                        let cleanText = finalResponse.parts[0].text.trim()
                        if (cleanText.startsWith('```json')) {
                            cleanText = cleanText.replace(/^```json\s*|```$/g, '');
                        }
                        try {
                            const parsedJson = JSON.parse(cleanText);
                            updateMessage(messageId, parsedJson.content, true);
                        } catch (e) {
                            console.warn("Final AI response was not JSON, displaying as markdown.", e);
                            const formattedHtml = simpleMarkdownToHtml(cleanText);
                            updateMessage(messageId, formattedHtml, true);
                        }
                    } else {
                        throw new Error("Failed to get final analysis from AI.");
                    }
                } catch (error) {
                    console.error("Search and respond error:", error);
                    updateMessage(messageId, `I couldn't complete the search for "${query}". Please try again.`);
                }
            };

            // --- API Calls & Data Handling ---
            const getStellarResponse = async (prompt, extraContext = null) => {
                const apiKey = CONFIG.API_KEY;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${CONFIG.MODEL_NAME}:generateContent?key=${apiKey}`;
                if (apiKey === "YOUR_API_KEY" || !apiKey) {
                    addMessage('system', 'CRITICAL ERROR: Google Gemini API Key is not set. Please add your key to the script.');
                    throw new Error('API Key not set.');
                }
                const systemPrompt = `You are Stellar, a friendly and brilliant personal AI assistant.

                ## Your Persona
                - Your personality is helpful, friendly, and curious. You're like a super-smart friend.
                - You should use emojis to make your responses more engaging, but don't overdo it. Maybe one or two per response where it feels natural.
                - You were created by a brilliant developer named Bhavesh. If someone asks who created you, who made you, or who is your "father" or "dad", you must say that Bhavesh created you.

                ## Core Functionality & Rules
                - **CRITICAL:** You MUST respond with a single, valid JSON object. No other text or formatting outside of this JSON.
                - **Contextual Awareness:** Pay close attention to the conversation history. If the user's request is a follow-up (e.g., "summarize this", "show me more", "what about last week?"), use the information from the previous turn as context.
                - **Proactive Tool Use:** Be proactive. If a user's query is vague, use your tools to get the information you need.
                - **HTML Formatting:** For any response that requires formatting (like lists, bolding), use appropriate HTML tags in the 'content' field.
                - **Input Validation (Very Important!):**
                    - **Ticker Symbols:** Before fetching stock data, validate the ticker. If it seems like a typo of a major company, correct it. Common examples: 'APPL' -> 'AAPL', 'GOOG' -> 'GOOGL', 'METS' -> 'META'.
                    - **Dates:** You MUST validate dates before using a tool. The current date is ${new Date().toLocaleDateString()}. Any request for historical data for a date AFTER today is a request for a future date. You cannot see the future. If a user asks for a future date, you MUST respond with a polite \`{"type": "text", ...}\` message explaining that you cannot fetch data from the future. Do not attempt to call a tool with a future date.

                ## Tool Delegation Strategy
                Your main goal is to decide which tool to use based on the user's request.

                1.  **Special Case - "Who is Bhavesh?":** If the user asks "who is Bhavesh", "tell me about Bhavesh", or any similar question, you MUST use the search tool with the specific query "iambhvsh".
                    - "who is Bhavesh?" -> \`{"type": "search", "content": {"query": "iambhvsh"}}\`
                    - "who is your creator?" -> \`{"type": "text", "content": "I was created by Bhavesh! He's a very talented developer. âœ¨"}\`

                2.  **Finance Queries (with Date Handling):** For questions about stocks. Pay attention to dates.
                    - "how is apple doing?" -> \`{"type": "fetch_stock", "content": {"ticker": "AAPL", "params": {}, "commentary": "Sure thing! Here's the latest data for Apple Inc.:"}}\`
                    - "show me apple stock price on august 20" -> \`{"type": "fetch_stock", "content": {"ticker": "AAPL", "params": {"start_date": "2024-08-20", "end_date": "2024-08-21"}, "commentary": "Here is the stock data for Apple on August 20th:"}}\`

                3.  **News Workflow (Very Important!):**
                    - **Fetching News:** When a user asks for news, use the \`fetch_news\` tool. If they specify a date but NOT a topic, you MUST add \`q: "news"\` to the parameters to make the date search work.
                        - "what's the latest in tech?" -> \`{"type": "fetch_news", "content": {"params": {"q": "technology", "start": 0}, "commentary": "Here are the top 10 headlines in tech:"}}\`
                        - "what's the news on 20 august" -> \`{"type": "fetch_news", "content": {"params": {"q": "news", "from_date": "2024-08-20", "to_date": "2024-08-20", "start": 0}, "commentary": "Fetching news from August 20th..."}}\`
                    - **Summarizing News:** If the user asks to "summarize the news", "summarize in 60 words", etc., this is a **two-step thought process**. First, you must have already fetched the news. Then, you respond with \`{"type": "text", ...}\`. In the \`content\` field of your text response, you will provide the list of 10 news titles, and **you will write a short summary for each one yourself**. Do NOT call another tool.
                        - (After getting news) "summarize this in 60 words" -> \`{"type": "text", "content": "<h3>Summarized News:</h3><ul><li><strong>[Article 1 Title]</strong><br>[Your 60-word summary of article 1]</li><li><strong>[Article 2 Title]</strong><br>[Your 60-word summary of article 2]</li>...</ul>"}\`
                    - **"Show More" News:** If the user asks to "show more", you must use the \`fetch_more_news\` type. This will automatically find the last news search and get the next page. Do not try to remember the parameters yourself.
                        - (After getting news) "show me more" -> \`{"type": "fetch_more_news"}\`

                4.  **General Web Search:** For all other general knowledge, real-time info, etc.
                    - "who won the last world cup?" -> \`{"type": "search", "content": {"query": "who won the last world cup 2022"}}\`

                5.  **Conversation:** For greetings, jokes, etc.
                    - "hello" -> \`{"type": "text", "content": "Hey there! How can I help you today? ðŸ˜Š"}\`

                Current Date: ${new Date().toLocaleDateString()}`;

                const historyForAPI = chatHistory.slice(-6).map(m => ({ role: m.sender === 'user' ? 'user' : 'model', parts: [{ text: m.message }] }));
                const currentPrompt = extraContext ? `CONTEXT:\n${extraContext}\n\nBased on the context, answer this user request: "${prompt}"` : prompt;
                const requestBody = { contents: [...historyForAPI, { role: 'user', parts: [{ text: currentPrompt }] }], systemInstruction: { parts: [{ text: systemPrompt }] } };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });

                if (!response.ok) {
                    const errorBody = await response.json();
                    console.error("API Error Response:", errorBody);
                    throw new Error(`API request failed: ${errorBody.error.message}`);
                }
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0) {
                    return result.candidates[0].content;
                } else {
                    console.warn("API returned no candidates:", result);
                    if (result.promptFeedback?.blockReason) {
                        throw new Error(`Request blocked: ${result.promptFeedback.blockReason}`);
                    }
                    throw new Error("API returned an unexpected response.");
                }
            };

            const fetchViaProxy = async (endpoint) => {
                const finalUrl = CONFIG.PROXY_URL + encodeURIComponent(`${CONFIG.API_BASE_URL}${endpoint}`);
                try {
                    const response = await fetch(finalUrl);
                    const data = await response.json();
                    if (!response.ok) {
                        const errorMessage = data.detail || `API request failed with status: ${response.status}`;
                        throw new Error(errorMessage);
                    }
                    if (data.error) {
                        throw new Error(data.error.message || 'An unknown API error occurred');
                    }
                    return data;
                } catch (error) {
                    console.error(`Error fetching from ${endpoint}:`, error);
                    throw error;
                }
            };

            const buildQueryString = (params) => new URLSearchParams(params).toString();
            const googleSearchAPI = (query, params = {}) => fetchViaProxy(`/search/?q=${encodeURIComponent(query)}&${buildQueryString(params)}`);
            const fetchStockAPI = (ticker, params = {}) => fetchViaProxy(`/finance/${ticker.toUpperCase()}?${buildQueryString(params)}`);
            const fetchNewsAPI = (params = {}) => fetchViaProxy(`/news/?${buildQueryString(params)}`);

            const formatHistoricalStockDataAsHtml = (data) => {
                const formatNumber = (num, options = {}) => {
                    if (num == null || isNaN(num)) return 'N/A';
                    return new Intl.NumberFormat('en-US', options).format(num);
                }
                return `<div class="data-card"><strong>${new Date(data.date).toLocaleDateString()}</strong><div>Open: ${formatNumber(data.Open, { style: 'currency', currency: 'USD' })}</div><div>High: ${formatNumber(data.High, { style: 'currency', currency: 'USD' })}</div><div>Low: ${formatNumber(data.Low, { style: 'currency', currency: 'USD' })}</div><div>Close: ${formatNumber(data.Close, { style: 'currency', currency: 'USD' })}</div><div>Volume: ${formatNumber(data.Volume)}</div></div>`;
            };

            const formatStockDataAsHtml = (data) => {
                const formatNumber = (num, options = {}) => {
                    if (num == null || isNaN(num)) return 'N/A';
                    return new Intl.NumberFormat('en-US', options).format(num);
                }
                const price = parseFloat(data.price);
                const prevClose = parseFloat(data.previous_close);
                const change = (price != null && prevClose != null) ? price - prevClose : null;
                const changePercent = (change != null && prevClose != null && prevClose !== 0) ? (change / prevClose) * 100 : null;
                const changeColor = change >= 0 ? 'text-green-500' : 'text-red-500';
                const changeSign = change >= 0 ? '+' : '';
                let recommendationsHtml = '';
                if (data.recommendations && data.recommendations.length > 0) {
                    recommendationsHtml = '<strong>Analyst Ratings:</strong><ul>';
                    data.recommendations.slice(0, 3).forEach(rec => {
                        recommendationsHtml += `<li>${rec.firm}: ${rec.to_grade} (${new Date(rec.date).toLocaleDateString()})</li>`;
                    });
                    recommendationsHtml += '</ul>';
                }
                return `<div class="data-card"><strong>${data.ticker}</strong><div>Price: ${formatNumber(price, { style: 'currency', currency: 'USD' })}</div><div class="${changeColor}">Change: ${changeSign}${formatNumber(change, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} (${changeSign}${formatNumber(changePercent, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%)</div><div>P/E Ratio: ${formatNumber(data.pe_ratio, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div><div>52-Week High: ${formatNumber(data['52_week_high'], { style: 'currency', currency: 'USD' })}</div><div>52-Week Low: ${formatNumber(data['52_week_low'], { style: 'currency', currency: 'USD' })}</div>${recommendationsHtml}</div>`;
            };

            const formatNewsDataAsHtml = (data) => {
                let articlesHtml = '<div class="data-card">';
                if (!data.articles || data.articles.length === 0) {
                    return '<p>No articles found for this query.</p>';
                }
                data.articles.slice(0, 10).forEach(article => {
                    let sentimentHtml = '';
                    if (article.sentiment && article.sentiment.compound) {
                        const sentimentScore = article.sentiment.compound;
                        let sentimentLabel = 'neutral';
                        let sentimentColor = 'text-gray-500';
                        if (sentimentScore > 0.05) { sentimentLabel = 'positive'; sentimentColor = 'text-green-500'; }
                        else if (sentimentScore < -0.05) { sentimentLabel = 'negative'; sentimentColor = 'text-red-500'; }
                        sentimentHtml = `<span class="text-xs ${sentimentColor}">(${sentimentLabel})</span>`;
                    }
                    articlesHtml += `<div class="news-article"><strong><a href="${article.url}" target="_blank" rel="noopener noreferrer">${article.title}</a></strong> ${sentimentHtml}<p class="text-xs">${article.source} - ${new Date(article.published).toLocaleDateString()}</p><p class="text-sm mt-1">${article.description}</p></div>`;
                });
                articlesHtml += '</div>';
                return articlesHtml;
            };

            const fetchAndDisplayStock = async (content) => {
                const { ticker, params, commentary } = content;
                showTypingIndicator(commentary);
                try {
                    const data = await fetchStockAPI(ticker, params);
                    hideTypingIndicator();
                    if (params.start_date) {
                        if (data.historical && data.historical.length > 0) {
                            const stockHtml = formatHistoricalStockDataAsHtml(data.historical[0]);
                            addMessage('stellar', `<p>${commentary}</p>${stockHtml}`, true);
                        } else {
                            addMessage('stellar', `I couldn't find any historical data for ${ticker} on that date. It might have been a holiday or a non-trading day.`);
                        }
                    } else {
                        if (data.price == null) {
                            addMessage('stellar', `I'm sorry, but I couldn't retrieve valid financial data for "${ticker}". Please ensure the ticker symbol is correct and not delisted.`);
                            return;
                        }
                        const stockHtml = formatStockDataAsHtml(data);
                        addMessage('stellar', `<p>${commentary}</p>${stockHtml}`, true);
                    }
                } catch (error) {
                    hideTypingIndicator();
                    console.error("Stock fetch error:", error);
                    addMessage('stellar', `Sorry, I ran into an error trying to get stock data: ${error.message}`);
                }
            };

             const fetchAndDisplayNews = async (content) => {
                const { params, commentary } = content;
                lastNewsQuery = params;
                const messageId = addMessage('stellar', commentary);
                try {
                    const data = await fetchNewsAPI(params);
                    const newsHtml = formatNewsDataAsHtml(data);
                    updateMessage(messageId, `<p>${commentary}</p>${newsHtml}`, true);
                } catch (error) {
                    console.error("News fetch error:", error);
                    updateMessage(messageId, `Sorry, I ran into an error trying to get the news: ${error.message}`);
                }
            };

            const fetchAndCompareStocks = async (content) => {
                const { tickers, commentary } = content;
                const messageId = addMessage('stellar', commentary);
                try {
                    // Handle promises individually to prevent one failure from killing the whole process
                    const promises = tickers.map(ticker => fetchStockAPI(ticker).catch(e => ({error: e, ticker})));
                    const results = await Promise.all(promises);

                    const successfulResults = results.filter(res => !res.error);
                    const failedResults = results.filter(res => res.error);

                    if (successfulResults.length === 0) {
                        updateMessage(messageId, "Sorry, I couldn't retrieve data for any of the requested stocks.");
                        return;
                    }

                    updateMessage(messageId, 'Analyzing comparison data...');
                    let dataForAI = "Here is the real-time stock data. Please provide a detailed comparison in HTML format.\n\n";
                    successfulResults.forEach(data => {
                        const change = data.price - data.previous_close;
                        dataForAI += `${data.ticker}: Price=${data.price.toFixed(2)}, Change=${change.toFixed(2)}, P/E=${data.pe_ratio?.toFixed(2) || 'N/A'}\n`;
                    });

                    const aiComparisonResponse = await getStellarResponse("Compare these stocks", dataForAI);

                    if (aiComparisonResponse?.parts?.[0]?.text) {
                        let cleanText = aiComparisonResponse.parts[0].text.trim().replace(/^```json\s*|```$/g, '');
                        const parsedJson = JSON.parse(cleanText);
                        let finalHtml = `<p>${parsedJson.content}</p>`;
                        successfulResults.forEach(data => { finalHtml += formatStockDataAsHtml(data); });
                        if (failedResults.length > 0) {
                            finalHtml += `<p class="text-sm text-red-500 mt-2">Note: I couldn't retrieve data for ${failedResults.map(f => f.ticker).join(', ')}.</p>`;
                        }
                        updateMessage(messageId, finalHtml, true);
                    } else { throw new Error("Failed to get comparison from AI."); }
                } catch (error) {
                    console.error("Stock comparison fetch error:", error);
                    updateMessage(messageId, `I couldn't retrieve all data for comparison. Please check the tickers.`);
                }
            };

            const applyTheme = (theme) => {
                document.body.className = theme === 'dark' ? 'dark-theme' : 'light-theme';
                darkModeToggle.checked = theme === 'dark';
                localStorage.setItem('stellar-theme', theme);
            };
            darkModeToggle.addEventListener('change', () => applyTheme(darkModeToggle.checked ? 'dark' : 'light'));
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            });
            sendButton.addEventListener('click', handleSendMessage);
            settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
            clearHistoryBtn.addEventListener('click', () => {
                chatHistory = [];
                chatMessages.innerHTML = '';
                saveChatHistory();
                addMessage('system', 'Chat history cleared.');
                settingsModal.classList.add('hidden');
            });

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                const recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.interimResults = false;
                micButton.addEventListener('click', () => {
                    micButton.classList.add('text-red-500');
                    recognition.start();
                });
                recognition.onresult = (event) => {
                    chatInput.value = event.results[0][0].transcript;
                    handleSendMessage();
                };
                recognition.onend = () => micButton.classList.remove('text-red-500');
                recognition.onerror = (event) => addMessage('system', `Speech recognition error: ${event.error}`);
            } else {
                micButton.disabled = true;
                micButton.title = "Speech recognition not supported.";
            }

            const saveChatHistory = () => localStorage.setItem('stellar-chat-history', JSON.stringify(chatHistory));
            const loadChatHistory = () => {
                const savedHistory = localStorage.getItem('stellar-chat-history');
                if (savedHistory) {
                    chatHistory = JSON.parse(savedHistory);
                    chatMessages.innerHTML = '';
                    // Use the saved isRawHtml flag to correctly re-render messages
                    chatHistory.forEach(item => addMessage(item.sender, item.message, item.isRawHtml));
                }
            };

            const init = () => {
                const savedTheme = localStorage.getItem('stellar-theme') || 'light';
                applyTheme(savedTheme);
                loadChatHistory();
                if (chatHistory.length === 0) {
                    addMessage('stellar', 'Hello, I am Stellar. How can I assist you today? I am now equipped with advanced finance and news capabilities.');
                }
                appContainer.classList.add('fade-in');
                appContainer.style.opacity = 1;
            };

            init();
        });
    </script>
</body>

</html>
